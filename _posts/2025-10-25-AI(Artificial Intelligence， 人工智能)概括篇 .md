---
title: AI(Artificial Intelligence， 人工智能)相关概念 
date: 2025-10-30 19:14:15 +0800
categories: [AI]
tags: [AI, THEORY]
---

> 前言: AI 技术发展太快了，`AIGC`、`RAG`、`Agent`、`Function Call`、`MCP` 等等的各种热词层出不穷的。本文就AI演变历程做一个简要的总结。

### AIGC（AI Generated Content, AI生成内容）

AIGC，即人工智能生成内容（Artificial Intelligence Generated Content），是指利用人工智能技术自动生成各种形式的内容，包括文本、图像、音频、视频、代码等。它通过深度学习、自然语言处理等技术，从大量数据中学习规律，并生成具有创造性的内容。

在实际应用中，AIGC已被广泛用于：

- 内容创作：如新闻稿、营销文案、小说写作
- 图像生成：如插画、设计图、广告素材
- 音视频制作：如语音合成、虚拟主播、短视频生成
- 编程辅助：如代码补全、错误检测、自动注释

> 最开始的ChatGTP实际上就是一种典型的文生文能力，AI通过人提供的`Prompt(提示词)`生成另外一段文字.

#### 分类

随着技术的发展，AIGC根据能够处理`类型`的多少被划分为以下两种：

- 单模态：只能处理*一种类型*内容， 比如：GPT-3 只懂文字，SD 只会画画。
- 多模态：支持*多种类型*消息，比如文生图，图生图，文生视频，图生视频等等。

#### 限制（技术角度）

- 滞后性（无法获取最新数据），AIGC依赖于知识库，需要不停的给AI喂数据，才能保证AIGC的生成内容的准确。 -> RAG(Retrieval-Augmented Generation, 检索增强生成)
- 无法使用工具，只能从现有知识库获取数据，无法使用现有API。 ->  Function Call(函数调用)

### RAG(Retrieval-Augmented Generation, 检索增强生成)

RAG(Retrieval-Augmented Generation, 检索增强生成) 是一种将*信息检索*与*语言生成*相结合的技术架构。它通过在生成回答前，先从外部知识库中检索相关信息，再将这些"新鲜"或"专有"的数据作为上下文输入给大模型，从而提升生成内容的准确性、时效性和专业性。

> 简单来说：RAG = 找资料 + 写文章。
> 就像学生写论文时先查文献，再动笔写作。

核心流程：

1. 用户提问：输入一个问题
2. 向量化检索：将问题转换为向量，在外部数据库（如文档库、数据库、网页索引）中搜索相似内容
3. 获取上下文：从知识库中提取最相关的片段（如财报PDF中的一页）
4. 增强生成：将原始问题 + 检索到的内容 一起送入大模型，生成最终回答

应用场景：

- 企业知识库问答系统
- 客服机器人（基于产品文档自动回答用户问题）
- 医疗咨询辅助（结合最新医学指南）
- 法律文书生成（引用具体法条和判例）

#### 限制

❌ 依赖高质量的外部知识源：垃圾进，垃圾出
❌ 检索不准会导致生成错误：检索失败 = 仍靠模型"猜"
❌ 多跳推理能力弱：复杂问题（如"为什么A导致B？"）难以跨多个文档推理
❌ 无法执行动作：只能"读"不能"写"，无法调用API、操作系统、执行任务

### Function Call（函数调用）

Function Call 是让大模型能够**主动调用外部工具或API**的能力。它使AI从"只会说话"进化到"能动手干活"。

> 简单来说：Function Call = 给AI配上"手脚"。
> 就像给助手一个工具箱，需要什么工具就拿什么。

#### 工作原理

1. **定义工具**：开发者预先定义一组函数（如查天气、发邮件、查数据库）
2. **用户提问**：用户输入需求（如"帮我查一下明天北京的天气"）
3. **模型判断**：大模型分析问题，决定需要调用哪个函数
4. **执行调用**：系统执行对应函数（如调用天气API）
5. **返回结果**：将函数返回值再交给模型，生成最终回答

#### 典型应用场景

- **智能客服**：查询订单状态、修改配送地址
- **办公助手**：发送邮件、创建日程、查询文档
- **数据分析**：查询数据库、生成报表、执行SQL
- **智能家居**：控制灯光、调节温度、播放音乐
- **金融交易**：查询股价、下单交易、风险评估

#### 与 RAG 的区别

| 维度 | RAG | Function Call |
|------|-----|---------------|
| 核心能力 | 检索 + 生成 | 判断 + 执行 |
| 数据来源 | 静态知识库 | 动态API调用 |
| 交互方式 | 只读（Read-only） | 可读可写（Read-Write） |
| 典型场景 | 知识问答、文档检索 | 任务执行、系统操作 |

#### 限制

❌ 需要预定义函数：无法处理未定义的工具
❌ 安全风险：错误调用可能导致数据泄露或系统损坏
❌ 单次调用限制：复杂任务需要多次调用，效率较低
❌ 缺乏规划能力：无法自主拆解复杂任务

### Agent（智能体）

Agent 是具有**自主规划、决策和执行能力**的AI系统。它不仅能调用工具，还能**自己决定调用顺序、处理异常、优化策略**。

> 简单来说：Agent = 有大脑的AI助手。
> 就像一个真正的员工，能独立完成复杂任务，而不是简单的"问答机器"。

#### 核心特征

1. **自主性（Autonomy）**：能独立决策，不需要每一步都问人
2. **反应性（Reactivity）**：能感知环境变化并做出响应
3. **主动性（Proactivity）**：能主动规划和执行任务
4. **社交性（Social Ability）**：能与其他Agent或人类协作

#### 工作流程

```
用户目标 → Agent规划 → 拆解子任务 → 调用工具 → 验证结果 → 调整策略 → 完成目标
```

**示例：用户说"帮我订一张明天去上海的机票"**

1. **理解意图**：需要订机票
2. **规划任务**：
   - 查询明天的航班
   - 比较价格和时间
   - 选择最优航班
   - 填写乘客信息
   - 完成支付
3. **执行调用**：
   - 调用航班查询API
   - 调用支付API
   - 发送确认邮件
4. **异常处理**：
   - 如果没票了，自动查询后天的
   - 如果支付失败，提示用户重试

#### 典型架构

**ReAct（Reasoning + Acting）**
- 思考（Thought）：分析当前状态
- 行动（Action）：调用工具
- 观察（Observation）：查看结果
- 循环迭代直到完成任务

**AutoGPT / BabyAGI**
- 自主设定子目标
- 递归拆解任务
- 持续执行直到完成

#### 应用场景

- **自动化运维**：监控系统、自动修复故障、生成报告
- **智能客服**：处理复杂售后流程（退款、换货、投诉）
- **研究助手**：自动搜索论文、总结要点、生成综述
- **代码助手**：自动修复bug、优化代码、编写测试
- **个人助理**：管理日程、处理邮件、安排行程

#### 与 Function Call 的区别

| 维度 | Function Call | Agent |
|------|---------------|-------|
| 决策能力 | 单次判断 | 多步规划 |
| 任务复杂度 | 简单任务 | 复杂任务 |
| 自主性 | 被动响应 | 主动执行 |
| 错误处理 | 需要人工介入 | 自动重试/调整策略 |

#### 限制

❌ 成本高：多次调用大模型，费用和延迟都较高
❌ 可控性差：自主决策可能偏离预期
❌ 安全风险：错误的规划可能导致严重后果
❌ 幻觉问题：复杂推理链容易出错

### MCP（Model Context Protocol, 模型上下文协议）

MCP 是一种**标准化的协议**，用于让AI模型与外部工具、数据源、服务进行**统一、安全、高效**的交互。

> 简单来说：MCP = AI的"USB接口"。
> 就像USB统一了设备连接标准，MCP统一了AI与工具的交互方式。

#### 为什么需要 MCP？

在 MCP 出现之前，每个AI应用都需要：
- 自己实现工具调用逻辑
- 自己处理权限和安全
- 自己管理上下文传递
- 不同工具的接口各不相同

**MCP 的价值**：
- ✅ 统一接口：所有工具遵循同一套协议
- ✅ 安全可控：标准化的权限管理和审计
- ✅ 易于扩展：新工具只需实现MCP协议即可接入
- ✅ 跨平台：不同AI模型都能使用同一套工具

#### 核心概念

**1. Resources（资源）**
- 文件、数据库、API等外部数据源
- 支持读取、搜索、订阅更新

**2. Tools（工具）**
- 可执行的函数或操作
- 如发送邮件、查询数据、控制设备

**3. Prompts（提示模板）**
- 预定义的提示词模板
- 帮助模型更好地理解任务

**4. Sampling（采样）**
- 让服务器端也能调用模型
- 支持多轮对话和复杂推理

#### 工作流程

```
AI模型 ←→ MCP Client ←→ MCP Server ←→ 外部工具/数据源
```

1. **AI模型**：发起请求（如"查询数据库"）
2. **MCP Client**：将请求转换为MCP协议格式
3. **MCP Server**：验证权限、执行操作
4. **外部工具**：返回结果
5. **MCP Client**：将结果返回给AI模型

#### 应用场景

- **企业级AI应用**：统一管理所有工具和数据源
- **多模型协作**：不同模型共享同一套工具
- **安全合规**：集中管理权限和审计日志
- **插件生态**：开发者可以轻松开发MCP兼容的工具

#### 与 Function Call 的关系

- **Function Call**：AI调用工具的**能力**
- **MCP**：AI调用工具的**标准协议**

就像：
- Function Call = "能打电话"
- MCP = "统一的电话号码格式和拨号规则"

#### 限制

❌ 生态尚未成熟：支持MCP的工具和平台还不多
❌ 学习成本：开发者需要学习新的协议规范
❌ 性能开销：多一层协议转换可能增加延迟

### 技术演进总结

```
AIGC（生成内容）
  ↓
RAG（检索增强，解决知识滞后）
  ↓
Function Call（调用工具，解决无法执行）
  ↓
Agent（自主规划，解决复杂任务）
  ↓
MCP（标准化协议，解决工具碎片化）
```

#### 各技术的适用场景

| 技术 | 适用场景 | 典型产品 |
|------|----------|----------|
| AIGC | 内容创作、代码生成 | ChatGPT、Midjourney、Copilot |
| RAG | 知识问答、文档检索 | 企业知识库、客服机器人 |
| Function Call | 简单任务执行 | ChatGPT Plugins、Claude Tools |
| Agent | 复杂任务自动化 | AutoGPT、LangChain Agents |
| MCP | 企业级AI平台 | Anthropic MCP、OpenAI Assistants API |

### 未来趋势

1. **多模态融合**：文本、图像、音频、视频的统一处理
2. **Agent协作**：多个Agent分工合作完成复杂任务
3. **边缘计算**：AI能力下沉到本地设备
4. **标准化协议**：MCP等协议成为行业标准
5. **安全与可控**：更强的权限管理和审计能力

### 总结

AI技术的发展是一个**从"能说"到"能做"，从"被动"到"主动"**的过程：

- **AIGC**：让AI能"说话"
- **RAG**：让AI能"查资料"
- **Function Call**：让AI能"动手"
- **Agent**：让AI能"独立思考"
- **MCP**：让AI能"标准化协作"

未来的AI应用，将是这些技术的**有机组合**，而不是单一技术的堆砌。选择合适的技术栈，才能构建真正有价值的AI产品。

### 参考资料

1. [OpenAI Function Calling 官方文档](https://platform.openai.com/docs/guides/function-calling)
2. [LangChain Agent 架构设计](https://python.langchain.com/docs/modules/agents/)
3. [Anthropic MCP 协议规范](https://modelcontextprotocol.io/)
4. [RAG 技术详解](https://arxiv.org/abs/2005.11401)
5. [ReAct: Synergizing Reasoning and Acting in Language Models](https://arxiv.org/abs/2210.03629)
